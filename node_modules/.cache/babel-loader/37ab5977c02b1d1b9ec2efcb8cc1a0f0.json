{"ast":null,"code":"import _toConsumableArray from \"/Users/michaelfoster/Git/avcmerchantappN/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"/Users/michaelfoster/Git/avcmerchantappN/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectWithoutProperties from \"/Users/michaelfoster/Git/avcmerchantappN/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _objectSpread from \"/Users/michaelfoster/Git/avcmerchantappN/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport _regeneratorRuntime from \"/Users/michaelfoster/Git/avcmerchantappN/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/michaelfoster/Git/avcmerchantappN/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/michaelfoster/Git/avcmerchantappN/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/michaelfoster/Git/avcmerchantappN/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/michaelfoster/Git/avcmerchantappN/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/michaelfoster/Git/avcmerchantappN/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/michaelfoster/Git/avcmerchantappN/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _assertThisInitialized from \"/Users/michaelfoster/Git/avcmerchantappN/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nvar _jsxFileName = \"/Users/michaelfoster/Git/avcmerchantappN/src/App.js\";\nimport * as Pusher from \"pusher-js\";\nimport React from 'react';\nimport { connect } from 'react-redux';\nimport { bindActionCreators } from 'redux';\nimport { BrowserRouter as Router } from \"react-router-dom\";\nimport { Route, Switch } from 'react-router'; // react-router v4\n\nimport { ToastContainer, toast } from \"react-toastify\";\nimport * as actions from './components/Common/actions/actions.js';\nimport NotFound from './components/NotFound/NotFound.js';\nimport LoadingScreen from './components/LoadingScreen/LoadingScreen.js';\nimport Airtable from \"./data/airtable\";\nimport Orders from \"./data/orders\";\nimport Items from \"./data/items\";\nimport Addons from \"./data/addons\";\nimport './App.css';\nimport \"react-toastify/dist/ReactToastify.css\"; // Pusher Setup and Channels\n// NOTE: Has to have the 'client-' prefix otherwise Pusher rejects the event.\n// https://pusher.com/docs/client_api_guide/client_events#trigger-events\n\nvar ORDER_COMPLETE_EVENT = \"client-complete-order\";\nvar ORDER_CHANNEL_NAME = \"private-order-channel\";\nvar ORDER_ADDED_EVENT = \"new-order\";\nvar pusher = new Pusher(process.env.REACT_APP_PUSHER_APP_KEY, {\n  authEndpoint: process.env.REACT_APP_PUSHER_DOMAIN + \"/pusher/auth\",\n  cluster: \"ap1\"\n}); //////////////////////////////////////////////////////////////////////////////\n\nvar App =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(App, _React$Component);\n\n  function App(props) {\n    var _this;\n\n    _classCallCheck(this, App);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(App).call(this, props));\n    _this.state = {\n      connectionStatus: {\n        previous: null,\n        current: \"connecting\"\n      },\n      currentView: '#pending'\n    };\n    _this.channel = null;\n    _this.updateOrderItem = _this.updateOrderItem.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.renderOrderItem = _this.renderOrderItem.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.mapOrdersToData = _this.mapOrdersToData.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.itemsWithData = _this.itemsWithData.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    return _this;\n  }\n\n  _createClass(App, [{\n    key: \"componentWillMount\",\n    value: function () {\n      var _componentWillMount = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        var _this2 = this;\n\n        var _this$props, getOrders, orders;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _this$props = this.props, getOrders = _this$props.getOrders, orders = _this$props.orders;\n                getOrders();\n\n                if (orders) {\n                  this.mapOrdersToData({\n                    orders: this.state.orders\n                  }).then(function (response) {\n                    if (response.success) {\n                      /**\n                       * Pusher has been added to listen to new orders from a customer.\n                       *\n                       * It will append new orders to the current state of orders so that the\n                       * staff are able to see them live.\n                       */\n                      _this2.channel = pusher.subscribe(ORDER_CHANNEL_NAME);\n\n                      _this2.channel.bind(ORDER_ADDED_EVENT, function (orders) {\n                        if (!Array.isArray(orders)) {\n                          return;\n                        }\n\n                        _this2.mapOrdersToData({\n                          orders: orders,\n                          appendOrders: true\n                        }).then(function (response) {\n                          toast.dismiss();\n                          toast(\"A new order has arrived!\");\n                        });\n                      });\n\n                      _this2.channel.bind(ORDER_COMPLETE_EVENT, function (_ref) {\n                        var orderToUpdate = _ref.orderToUpdate;\n\n                        if (orderToUpdate) {\n                          _this2.updateOrderItem(orderToUpdate, true);\n                        }\n                      });\n                    } else {\n                      toast.error(\"Having troubles loading, please refresh the page.\");\n                    }\n                  });\n                }\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function componentWillMount() {\n        return _componentWillMount.apply(this, arguments);\n      }\n\n      return componentWillMount;\n    }()\n  }, {\n    key: \"componentWillUpdate\",\n    value: function () {\n      var _componentWillUpdate = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2() {\n        var _this3 = this;\n\n        var _this$props2, getOrders, orders;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _this$props2 = this.props, getOrders = _this$props2.getOrders, orders = _this$props2.orders;\n                getOrders();\n\n                if (orders) {\n                  this.mapOrdersToData({\n                    orders: this.state.orders\n                  }).then(function (response) {\n                    if (response.success) {\n                      /**\n                       * Pusher has been added to listen to new orders from a customer.\n                       *\n                       * It will append new orders to the current state of orders so that the\n                       * staff are able to see them live.\n                       */\n                      _this3.channel = pusher.subscribe(ORDER_CHANNEL_NAME);\n\n                      _this3.channel.bind(ORDER_ADDED_EVENT, function (orders) {\n                        if (!Array.isArray(orders)) {\n                          return;\n                        }\n\n                        _this3.mapOrdersToData({\n                          orders: orders,\n                          appendOrders: true\n                        }).then(function (response) {\n                          toast.dismiss();\n                          toast(\"A new order has arrived!\");\n                        });\n                      });\n\n                      _this3.channel.bind(ORDER_COMPLETE_EVENT, function (_ref2) {\n                        var orderToUpdate = _ref2.orderToUpdate;\n\n                        if (orderToUpdate) {\n                          _this3.updateOrderItem(orderToUpdate, true);\n                        }\n                      });\n                    } else {\n                      toast.error(\"Having troubles loading, please refresh the page.\");\n                    }\n                  });\n                }\n\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function componentWillUpdate() {\n        return _componentWillUpdate.apply(this, arguments);\n      }\n\n      return componentWillUpdate;\n    }()\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      localStorage.clear('persist:persistedStore');\n    }\n  }, {\n    key: \"updateOrderItem\",\n    value: function updateOrderItem(orderToUpdate) {\n      var _this4 = this;\n\n      var isFromPusher = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      this.setState({\n        orders: this.state.orders.map(function (order) {\n          if (order.id === orderToUpdate.id) {\n            return _objectSpread({}, order, orderToUpdate);\n          }\n\n          return order;\n        })\n      }, function () {\n        // TODO: Notify others in the channel that we have updated an order item\n        // We don't want other staff seeing an order that has been completed, you know??\n        if (!isFromPusher) {\n          _this4.channel.trigger(ORDER_COMPLETE_EVENT, {\n            orderToUpdate: orderToUpdate\n          });\n        }\n      });\n    }\n  }, {\n    key: \"mapOrdersToData\",\n    value: function mapOrdersToData(_ref3) {\n      var _this5 = this;\n\n      var orders = _ref3.orders,\n          _ref3$appendOrders = _ref3.appendOrders,\n          appendOrders = _ref3$appendOrders === void 0 ? false : _ref3$appendOrders;\n      var updateOrder = this.props.updateOrder;\n      return new Promise(function (resolve, reject) {\n        try {\n          var squishedOrders = orders.reduce(function (result, currentOrder) {\n            var item_id = currentOrder.item_id,\n                addons = currentOrder.addons,\n                quantity = currentOrder.quantity,\n                rest = _objectWithoutProperties(currentOrder, [\"item_id\", \"addons\", \"quantity\"]);\n\n            var _item_id = _slicedToArray(item_id, 1),\n                itemId = _item_id[0]; // Grab the first as we only ever have 1 item id\n\n\n            var possibleTransaction = result.findIndex(function (order) {\n              return order.stripe_transaction_id === currentOrder.stripe_transaction_id;\n            });\n            var currentTransaction = result[possibleTransaction] || rest;\n\n            if (!currentTransaction.combinedItems) {\n              currentTransaction.combinedItems = [{\n                item_id: itemId,\n                addons: addons,\n                quantity: quantity\n              }];\n            } else {\n              currentTransaction.combinedItems.push({\n                item_id: itemId,\n                addons: addons,\n                quantity: quantity\n              });\n            }\n\n            if (possibleTransaction > -1) {\n              result[possibleTransaction] = currentTransaction;\n            } else {\n              result.push(currentTransaction);\n            }\n\n            return result;\n          }, []);\n          updateOrderState({\n            orders: [].concat(_toConsumableArray(squishedOrders.map(function (order) {\n              return _objectSpread({}, order, {\n                items: _this5.itemsWithData(order)\n              });\n            })), _toConsumableArray(appendOrders ? _this5.state.orders : [])),\n            isLoading: false\n          }, function () {\n            resolve({\n              success: true\n            });\n          });\n        } catch (error) {\n          reject({\n            success: false,\n            error: error\n          });\n        }\n      });\n    }\n  }, {\n    key: \"routeTo\",\n    value: function routeTo(suffix) {\n      window.location = \"/\".concat(suffix);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      // eslint-disable-next-line\n      var _this$props3 = this.props,\n          router = _this$props3.router,\n          venueNames = _this$props3.venueNames,\n          isLoading = _this$props3.isLoading;\n      console.log(this.props.orders); // const path = router.location.pathname.split('/')[1];\n      // const showMenu = venueNames ? venueNames.includes(path) ? true : false : false;\n\n      return React.createElement(\"div\", {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 227\n        },\n        __self: this\n      });\n    }\n  }]);\n\n  return App;\n}(React.Component);\n\nvar mapDispatchToProps = function mapDispatchToProps(dispatch) {\n  return bindActionCreators(actions, dispatch);\n};\n\nvar mapStateToProps = function mapStateToProps(state) {\n  return {\n    router: state.router,\n    orders: state.common.orders\n  };\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(App);","map":{"version":3,"sources":["/Users/michaelfoster/Git/avcmerchantappN/src/App.js"],"names":["Pusher","React","connect","bindActionCreators","BrowserRouter","Router","Route","Switch","ToastContainer","toast","actions","NotFound","LoadingScreen","Airtable","Orders","Items","Addons","ORDER_COMPLETE_EVENT","ORDER_CHANNEL_NAME","ORDER_ADDED_EVENT","pusher","process","env","REACT_APP_PUSHER_APP_KEY","authEndpoint","REACT_APP_PUSHER_DOMAIN","cluster","App","props","state","connectionStatus","previous","current","currentView","channel","updateOrderItem","bind","renderOrderItem","mapOrdersToData","itemsWithData","getOrders","orders","then","response","success","subscribe","Array","isArray","appendOrders","dismiss","orderToUpdate","error","localStorage","clear","isFromPusher","setState","map","order","id","trigger","updateOrder","Promise","resolve","reject","squishedOrders","reduce","result","currentOrder","item_id","addons","quantity","rest","itemId","possibleTransaction","findIndex","stripe_transaction_id","currentTransaction","combinedItems","push","updateOrderState","items","isLoading","suffix","window","location","router","venueNames","console","log","Component","mapDispatchToProps","dispatch","mapStateToProps","common"],"mappings":"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","sourcesContent":["import * as Pusher from \"pusher-js\";\nimport React from 'react';\nimport {connect} from 'react-redux'\nimport {bindActionCreators} from 'redux'\nimport { BrowserRouter as Router} from \"react-router-dom\";\nimport { Route, Switch } from 'react-router' // react-router v4\nimport { ToastContainer, toast } from \"react-toastify\";\n\nimport * as actions from './components/Common/actions/actions.js';\nimport NotFound from './components/NotFound/NotFound.js';\nimport LoadingScreen from './components/LoadingScreen/LoadingScreen.js';\nimport Airtable from \"./data/airtable\";\nimport Orders from \"./data/orders\";\nimport Items from \"./data/items\";\nimport Addons from \"./data/addons\";\n\nimport './App.css';\nimport \"react-toastify/dist/ReactToastify.css\";\n\n// Pusher Setup and Channels\n// NOTE: Has to have the 'client-' prefix otherwise Pusher rejects the event.\n// https://pusher.com/docs/client_api_guide/client_events#trigger-events\nconst ORDER_COMPLETE_EVENT = \"client-complete-order\";\nconst ORDER_CHANNEL_NAME = \"private-order-channel\";\nconst ORDER_ADDED_EVENT = \"new-order\";\nconst pusher = new Pusher(process.env.REACT_APP_PUSHER_APP_KEY, {\n  authEndpoint: process.env.REACT_APP_PUSHER_DOMAIN + \"/pusher/auth\",\n  cluster: \"ap1\"\n});\n//////////////////////////////////////////////////////////////////////////////\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      connectionStatus: {\n        previous: null,\n        current: \"connecting\"\n      },\n      currentView: '#pending',\n    };\n\n    this.channel = null;\n\n    this.updateOrderItem = this.updateOrderItem.bind(this);\n    this.renderOrderItem = this.renderOrderItem.bind(this);\n    this.mapOrdersToData = this.mapOrdersToData.bind(this);\n    this.itemsWithData = this.itemsWithData.bind(this);\n  }\n\n  async componentWillMount(){\n    const { getOrders, orders } = this.props;\n    getOrders();\n\n    if(orders){\n      this.mapOrdersToData({ orders: this.state.orders }).then(response => {\n        if (response.success) {\n          /**\n           * Pusher has been added to listen to new orders from a customer.\n           *\n           * It will append new orders to the current state of orders so that the\n           * staff are able to see them live.\n           */\n          this.channel = pusher.subscribe(ORDER_CHANNEL_NAME);\n          this.channel.bind(ORDER_ADDED_EVENT, orders => {\n            if (!Array.isArray(orders)) {\n              return;\n            }\n            this.mapOrdersToData({ orders, appendOrders: true }).then(\n              response => {\n                toast.dismiss();\n                toast(\"A new order has arrived!\");\n              }\n            );\n          });\n          this.channel.bind(ORDER_COMPLETE_EVENT, ({ orderToUpdate }) => {\n            if (orderToUpdate) {\n              this.updateOrderItem(orderToUpdate, true);\n            }\n          });\n        } else {\n          toast.error(\"Having troubles loading, please refresh the page.\");\n        }\n      });\n    }\n  }\n\n  async componentWillUpdate(){\n    const { getOrders, orders } = this.props;\n    getOrders();\n\n    if(orders){\n      this.mapOrdersToData({ orders: this.state.orders }).then(response => {\n        if (response.success) {\n          /**\n           * Pusher has been added to listen to new orders from a customer.\n           *\n           * It will append new orders to the current state of orders so that the\n           * staff are able to see them live.\n           */\n          this.channel = pusher.subscribe(ORDER_CHANNEL_NAME);\n          this.channel.bind(ORDER_ADDED_EVENT, orders => {\n            if (!Array.isArray(orders)) {\n              return;\n            }\n            this.mapOrdersToData({ orders, appendOrders: true }).then(\n              response => {\n                toast.dismiss();\n                toast(\"A new order has arrived!\");\n              }\n            );\n          });\n          this.channel.bind(ORDER_COMPLETE_EVENT, ({ orderToUpdate }) => {\n            if (orderToUpdate) {\n              this.updateOrderItem(orderToUpdate, true);\n            }\n          });\n        } else {\n          toast.error(\"Having troubles loading, please refresh the page.\");\n        }\n      });\n    }\n  }\n\n  componentWillUnmount(){\n    localStorage.clear('persist:persistedStore')\n  }\n\n  updateOrderItem(orderToUpdate, isFromPusher = false) {\n    this.setState(\n      {\n        orders: this.state.orders.map(order => {\n          if (order.id === orderToUpdate.id) {\n            return {\n              ...order,\n              ...orderToUpdate\n            };\n          }\n          return order;\n        })\n      },\n      () => {\n        // TODO: Notify others in the channel that we have updated an order item\n        // We don't want other staff seeing an order that has been completed, you know??\n\n        if (!isFromPusher) {\n          this.channel.trigger(ORDER_COMPLETE_EVENT, { orderToUpdate });\n        }\n      }\n    );\n  }\n\n  mapOrdersToData({ orders, appendOrders = false }) {\n    const { updateOrder } = this.props;\n    return new Promise((resolve, reject) => {\n      try {\n        const squishedOrders = orders.reduce((result, currentOrder) => {\n          const { item_id, addons, quantity, ...rest } = currentOrder;\n          const [itemId] = item_id; // Grab the first as we only ever have 1 item id\n          const possibleTransaction = result.findIndex(\n            order =>\n              order.stripe_transaction_id === currentOrder.stripe_transaction_id\n          );\n\n          let currentTransaction = result[possibleTransaction] || rest;\n\n          if (!currentTransaction.combinedItems) {\n            currentTransaction.combinedItems = [\n              {\n                item_id: itemId,\n                addons,\n                quantity\n              }\n            ];\n          } else {\n            currentTransaction.combinedItems.push({\n              item_id: itemId,\n              addons,\n              quantity\n            });\n          }\n\n          if (possibleTransaction > -1) {\n            result[possibleTransaction] = currentTransaction;\n          } else {\n            result.push(currentTransaction);\n          }\n\n          return result;\n        }, []);\n\n        updateOrderState(\n          {\n            orders: [\n              ...squishedOrders.map(order => {\n                return {\n                  ...order,\n                  items: this.itemsWithData(order)\n                };\n              }),\n              ...(appendOrders ? this.state.orders : [])\n            ],\n            isLoading: false\n          },\n          () => {\n            resolve({ success: true });\n          }\n        );\n      } catch (error) {\n        reject({ success: false, error });\n      }\n    });\n  }\n\n  routeTo(suffix){\n    window.location = `/${suffix}`;\n  }\n\n  render() {\n    // eslint-disable-next-line\n    const { router, venueNames, isLoading } = this.props\n    console.log(this.props.orders);\n    // const path = router.location.pathname.split('/')[1];\n    // const showMenu = venueNames ? venueNames.includes(path) ? true : false : false;\n    return (\n      <div></div>\n    );\n  }\n}\n\n\nconst mapDispatchToProps = dispatch => bindActionCreators(actions, dispatch);\n\nconst mapStateToProps = state => ({\n  router: state.router,\n  orders: state.common.orders,\n});\n\nexport default connect(mapStateToProps, mapDispatchToProps)(App);\n"]},"metadata":{},"sourceType":"module"}